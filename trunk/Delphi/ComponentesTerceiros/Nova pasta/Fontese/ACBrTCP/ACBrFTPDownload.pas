{******************************************************************************}
{ Projeto: Componentes ACBr                                                    }
{  Biblioteca multiplataforma de componentes Delphi para interação com equipa- }
{ mentos de Automação Comercial utilizados no Brasil                           }
{                                                                              }
{ Direitos Autorais Reservados (c) 2004 Daniel Simoes de Almeida               }
{                                                                              }
{ Colaboradores nesse arquivo: Isaque Pinheiro                                 }
{                                                                              }
{  Você pode obter a última versão desse arquivo na pagina do  Projeto ACBr    }
{ Componentes localizado em      http://www.sourceforge.net/projects/acbr      }
{                                                                              }
{ Esse arquivo usa a classe  SynaSer   Copyright (c)2001-2003, Lukas Gebauer   }
{  Project : Ararat Synapse     (Found at URL: http://www.ararat.cz/synapse/)  }
{                                                                              }
{  Esta biblioteca é software livre; você pode redistribuí-la e/ou modificá-la }
{ sob os termos da Licença Pública Geral Menor do GNU conforme publicada pela  }
{ Free Software Foundation; tanto a versão 2.1 da Licença, ou (a seu critério) }
{ qualquer versão posterior.                                                   }
{                                                                              }
{  Esta biblioteca é distribuída na expectativa de que seja útil, porém, SEM   }
{ NENHUMA GARANTIA; nem mesmo a garantia implícita de COMERCIABILIDADE OU      }
{ ADEQUAÇÃO A UMA FINALIDADE ESPECÍFICA. Consulte a Licença Pública Geral Menor}
{ do GNU para mais detalhes. (Arquivo LICENÇA.TXT ou LICENSE.TXT)              }
{                                                                              }
{  Você deve ter recebido uma cópia da Licença Pública Geral Menor do GNU junto}
{ com esta biblioteca; se não, escreva para a Free Software Foundation, Inc.,  }
{ no endereço 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.          }
{ Você também pode obter uma copia da licença em:                              }
{ http://www.opensource.org/licenses/lgpl-license.php                          }
{                                                                              }
{ Daniel Simões de Almeida  -  daniel@djsystem.com.br  -  www.djsystem.com.br  }
{              Praça Anita Costa, 34 - Tatuí - SP - 18270-410                  }
{                                                                              }
{******************************************************************************}

{******************************************************************************
|* Historico
|*
|* 27/10/2011: Primeira Versao
|*    Isaque Pinheiro e Daniel Simoes de Almeida
|*    Criaçao do componente ACBrDownload, que implementa de fazer download de
|*    arquivos via http e ftp, com recurso de pausa e continuação do download.
******************************************************************************}

{$I ACBr.inc}

unit ACBrFTPDownload;

interface

uses
  Classes, SysUtils,
  ACBrUtil, ACBrBase, ACBrDownloadClass,
  ftpsend, blcksock, synautil;

type
  TACBrFTPDownload = class(TACBrDownloadClass)
  private
    fFTPSend: TFTPSend;
    fFTP: TACBrFTP;

  protected
    procedure DoHookStatus(Sender: TObject; Reason: THookSocketReason;
      const Value: String); override;
  public
    constructor Create(AOwner: TComponent);
    destructor Destroy; override;

    procedure StartDownload; override;
  published
    property FTP: TACBrFTP read fFTP write fFTP;
  end;

implementation

uses ACBrDownload;

{ TACBrFTPDownload }

constructor TACBrFTPDownload.Create(AOwner: TComponent);
begin
  fFTPSend                 := TFTPSend.Create;
  fFTPSend.DSock.OnStatus  := DoHookStatus;
  fFTPSend.DSock.OnMonitor := DoHookMonitor;

  fDocument := fFTPSend.DataStream;
  fSock     := fFTPSend.DSock;
  inherited Create(AOwner);

  fFTP := TACBrDownload(AOwner).FTP;
end;

destructor TACBrFTPDownload.Destroy;
begin
  fFTPSend.DSock.OnStatus  := nil;
  fFTPSend.DSock.OnMonitor := nil;

  if Assigned(fFTP) then
     fFTP := nil;

  fFTPSend.Free;
  inherited Destroy;
end;

procedure TACBrFTPDownload.DoHookStatus(Sender: TObject; Reason: THookSocketReason;
  const Value: String);
begin
  fResultCode := fFTPSend.ResultCode;
  case Reason of
     HR_SocketClose:
     begin
       if fResultCode = 227  then // Inicializando
          Exit;
     end;
  end;
  inherited;
end;

procedure TACBrFTPDownload.StartDownload;
var
  Prot, User, Pass, Host, Port, Path, Para : String;
begin
  try
    if (fFilePart = '') and (fDownloadStatus <> stRedirect) then
    begin
       Prot := '';
       User := '';
       Pass := '';
       Host := '';
       Port := '';
       Path := '';
       Para := '';
       ParseURL(fDownloadUrl, Prot, User, Pass, Host, Port, Path, Para);

       // Configuração FTP
       fFTPSend.TargetHost := fFTP.FtpHost;
       fFTPSend.TargetPort := fFTP.FtpPort;
       fFTPSend.Username   := fFTP.FtpUser;
       fFTPSend.Password   := fFTP.FtpPass;

       // Definição do Proxy
//       fFTPSend.DSock.SocksIP       := fProxy.ProxyHost;
//       fFTPSend.DSock.SocksPort     := fProxy.ProxyPort;
//       fFTPSend.DSock.SocksUsername := fProxy.ProxyUser;
//       fFTPSend.DSock.SocksPassword := fProxy.ProxyPass;

       // ReplaceString foi chamado aqui porque no Delphi não reconhece barra "/"
       // como o Lazarus que reconhece os dois.
       fFilePart := ExtractFileName(ReplaceString(Path, '/', '\'));

       if fFilePart <> '' then
          fFilePart := fFilePart + '.part';
    end;
    // FTP Login
    if not fFTPSend.Login then
      Exit;

//    if fProxy.ProxyHost <> '' then
//    begin
//       if not fFTPSend.DSock Login then
//         Exit;
//    end;

    if fFilePart = '' then
       raise Exception.Create('File To Save not found');

    // Abrir ou Criar o arquivo de download
    OpenCreateFile;

    fFTPSend.DirectFileName := fFilePart;
    fFTPSend.DirectFile := False;

    fDownloadSize := fFTPSend.FileSize(Path);
//    fDownloadSize := fDownloadSize - fFileStream.Size;

    // Evento
    if Assigned(fOnBeforeDownload) then
       fOnBeforeDownload(Self);

    fFTPSend.RetrieveFile(Path, False);

    // Evento
    if Assigned(fOnAfterDownload) then
       fOnAfterDownload(Self);

  finally
     fFTPSend.Logout;
  end;
end;

end.
